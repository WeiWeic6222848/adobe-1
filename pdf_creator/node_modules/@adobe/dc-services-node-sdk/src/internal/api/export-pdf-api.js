/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const ExtensionMediaTypeMapping = require('../extension-mediatype-mapping'),
	logger = require('./../logger'),
	CPFApi = require('./cpf-api'),
	Engine = require('../cpf/request/engine.js'),
	ContentAnalyzerRequests = require('../cpf/request/contentAnalyzerRequests.js'),
	cpfConfig = require('../config/cpf-engine-config.js'),
	Document = require('../cpf/request/document.js');

	ExportPDFApi = {

		exportPDF(context, sourceFileRef,exportTargetFormat, targetFileName) {

			const inputDocument = new Document(sourceFileRef.input.mediaType,'file0');
			var outputDocument = new Document(exportTargetFormat.mediaType,'file');
			if(exportTargetFormat.extension === 'png' ||  exportTargetFormat.extension === 'jpeg')
				outputDocument = new Document('application/zip','file');

			const params = Object.assign({},{targetFormat:exportTargetFormat.extension});

			const engine = new Engine(inputDocument,params,outputDocument);
			const contentAnaylzerRequests = new ContentAnalyzerRequests(cpfConfig.exportPdf,engine);

			var contentAnaylzerRequestsJsonString = JSON.stringify(contentAnaylzerRequests);
			var file = [sourceFileRef];
			return CPFApi.cpfPredictApi(context, file, contentAnaylzerRequestsJsonString)
				.then(location => {
					return CPFApi.cpfStatusApi(context, location, targetFileName);})
				.then(targetFileRef => {
					targetFileRef.input.isOperationResult = true;
					logger.info('Conversion successfully completed');
					return targetFileRef;
				})
				.catch(res => Promise.reject(res));
		}
	};

module.exports = ExportPDFApi;
