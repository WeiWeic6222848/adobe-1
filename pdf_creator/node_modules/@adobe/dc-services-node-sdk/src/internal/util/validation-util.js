/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const inputTypes = require('./../io/input-types'),
	ExtensionMediaTypeMapping = require('./../extension-mediatype-mapping'),
	fs = require('fs'),
	FileRef = require('./../../io/file-ref'),
	PageRanges = require('./../../operation/option/page-ranges');

function validateClientContext(context) {
	if (!context || !context.clientConfig) {
		throw new Error('Client Context not initialized before invoking the operation');
	}

	context.clientConfig.validate();
	context.validate();
}

function isStringType(string) {
	return typeof (string) === 'string' || string instanceof String;
}

function validateMediaType(mediaType) {
	if (!mediaType) {
		throw new Error('Source file mediatype must not be null');
	}
	if (!isStringType(mediaType)) {
		throw new TypeError('Source file mediatype should be string');
	}
	if (!(ExtensionMediaTypeMapping.getExtensionFromMediaType(mediaType))) {
		throw new Error(`${mediaType} media type is not allowed`);
	}
}

/* eslint default-case:0
no-case-declarations:0 */
function validateFileRef(sourceFileRef) {
	if (!sourceFileRef) {
		throw new Error('No input was set for operation');
	}
	if (!(sourceFileRef instanceof FileRef)) {
		throw new Error('Input should be a Fileref instance');
	}

	const fileInfo = sourceFileRef.input;

	switch (fileInfo.inputType) {
		case inputTypes.localFile:
			if (!fileInfo.fileSource) {
				throw new Error('Source file path must not be null');
			}
			if (!(typeof (fileInfo.fileSource) === 'string' || fileInfo.fileSource instanceof String)) {
				throw new TypeError('Source file path should be string');
			}
			if (!(fs.existsSync(fileInfo.fileSource))) {
				throw new Error(`no such file or directory, ${fileInfo.fileSource}`);
			}
			break;
		case inputTypes.stream:
			if (!fileInfo.fileSource) {
				throw new Error('Source inputStream must not be null');
			}
			break;
	}
	validateMediaType(fileInfo.mediaType);
}

function validateAllowedMediaType(allowedMediaTypes, sourceFileRef) {
	if (!allowedMediaTypes.includes(sourceFileRef.input.mediaType)) {
		throw new Error(`Operation cannot be performed on the specified input media type : ${
			sourceFileRef.input.mediaType}`);
	}
}

function validateOptionInstanceType(mediaTypeOptionClassMap, sourceFileRef, options) {
	const mediaType = sourceFileRef.input.mediaType,
		instanceType = mediaTypeOptionClassMap.get(ExtensionMediaTypeMapping.getFormatFromMediaType(mediaType));
	if (!instanceType || !(options instanceof instanceType)) {
		throw new Error(`Invalid option instance type provided for source media type ${mediaType}`);
	}
}

function validateOperationOptions(options) {
	const errors = options.validate();
	if (errors.length > 0) {
		const messages = [];
		errors.forEach(err => messages.push(err.message));
		throw new Error(messages.join('; '));
	}
}

function validatePageRanges(pageRanges) {
	if (!(pageRanges instanceof PageRanges)) {
		throw new Error('CombineOperation expects only PageRanges instance as 2nd argument for addInput');
	}
	if (!pageRanges) {
		throw new Error('No page options provided for combining files PDFs');
	}
	pageRanges.validate();
}

function validateFileWithPageOptions(input, allowedMediaTypes) {
	validateFileRef(input.getSourceFileRef());
	validateAllowedMediaType(allowedMediaTypes, input.getSourceFileRef());
	validatePageRanges(input.getPageRanges());
}

module.exports = {
	validateClientContext,
	validateFileRef,
	validateAllowedMediaType,
	validateOptionInstanceType,
	validateOperationOptions,
	validateFileWithPageOptions
};
