/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const ExtensionMediaTypeMapping = require('../extension-mediatype-mapping'),
	logger = require('./../logger'),
	CPFApi = require('./cpf-api'),
 	Engine = require('../cpf/request/engine.js'),
 	ContentAnalyzerRequests = require('../cpf/request/contentAnalyzerRequests.js'),
 	cpfConfig = require('../config/cpf-engine-config.js'),
 	Document = require('../cpf/request/document.js');


	CreatePDFApi = {

		/**
	 *
	 * @param context
	 * @param assetUri value of the uploaded source URI or the external url provided by the client
	 * @param sourceFileRef
	 * @param createPDFOptions
	 * @param targetFileName
	 * @returns {a|*|Promise<T | never>}
	 */

		convertToPdf(context, sourceFileRef, targetFileName,createPDFOptions) {

			switch (sourceFileRef.input.extension) {
				case ExtensionMediaTypeMapping.zip.extension:{
					const inputDocument = new Document(sourceFileRef.input.mediaType,'file0');
					const outputDocument = new Document('application/pdf','file');
					var params = {};
					if(createPDFOptions)
						params = Object.assign({},
											   {
												   includeHeaderFooter:createPDFOptions.includeHeaderFooter,
												   pageWidth:createPDFOptions.pageLayout.pageWidth,
												   pageHeight:createPDFOptions.pageLayout.pageHeight,
												   json:JSON.stringify(createPDFOptions.dataToMerge)
											   });

					const engine = new Engine(inputDocument,params,outputDocument);
					const contentAnaylzerRequests = new ContentAnalyzerRequests(cpfConfig.htmlToPdf,engine);
					let contentAnaylzerRequestsJsonString = JSON.stringify(contentAnaylzerRequests);

					var file = [sourceFileRef];
					return CPFApi.cpfPredictApi(context, file, contentAnaylzerRequestsJsonString)
						.then(location => {
							return CPFApi.cpfStatusApi(context, location, targetFileName);})
						.then(targetFileRef => {
							targetFileRef.input.isOperationResult = true;
							logger.info('Conversion successfully completed');
							return targetFileRef;
						})
						.catch(res => Promise.reject(res));
				}

				default:{
					const inputDocument = new Document(sourceFileRef.input.mediaType,'file0');
					const outputDocument = new Document('application/pdf','file');
					const engine = new Engine(inputDocument,params,outputDocument);
					const contentAnaylzerRequests = new ContentAnalyzerRequests(cpfConfig.createPdf,engine);
					var contentAnaylzerRequestsJsonString = JSON.stringify(contentAnaylzerRequests);
					var file = [sourceFileRef];
					return CPFApi.cpfPredictApi(context, file, contentAnaylzerRequestsJsonString)
						.then(location => {
							return CPFApi.cpfStatusApi(context, location, targetFileName);})
						.then(targetFileRef => {
							targetFileRef.input.isOperationResult = true;
							logger.info('Conversion successfully completed');
							return targetFileRef;
						})
						.catch(res => Promise.reject(res));
				}

			}


		}
	};

module.exports = CreatePDFApi;
