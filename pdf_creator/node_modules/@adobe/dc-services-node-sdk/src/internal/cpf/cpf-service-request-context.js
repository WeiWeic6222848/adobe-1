/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const CPFRequestKeys = require('./cpf-service-request-key'),
	_ = require('lodash-core'),
	HttpRequest = require('../http/http-request');


class CPFServiceRequestContext {
	constructor(clientConfig) {
		Object.defineProperty(this, 'clientConfig', {
			value: clientConfig,
			writable: false
		});


		this.baseOptions = null;

	}

	setOptionsMaps() {

		const baseOptions = new Map();

		// Common V2 request options
		let cpfRequestOptions = {
			headers: {
				'Accept': 'application/json, text/plain, */*',
			},
			authenticate: true
		};

		// Initialize V2 Predict template
		const cpfPredictRequestOptions = {};
		cpfPredictRequestOptions.requestConfig = {
			method: 'POST',
			uriTemplate: this.clientConfig.v2PredictUri,
			connectTimeout: this.clientConfig.connectTimeout,
			readTimeout: this.clientConfig.readTimeout
		};
		cpfPredictRequestOptions.request_content_open = true;

		// Add default headers and any custom options.
		_.extend(cpfPredictRequestOptions, cpfRequestOptions);
		baseOptions.set(CPFRequestKeys.CPF_PREDICT, cpfPredictRequestOptions);

		// Initialize V2 Status template
		const cpfStatusRequestOptions = {};
		cpfStatusRequestOptions.requestConfig = {
			method: 'GET',
			connectTimeout: this.clientConfig.connectTimeout,
			readTimeout: this.clientConfig.readTimeout
		};
		cpfStatusRequestOptions.response_content_open = true;

		// Add default headers and any custom options.
		_.extend(cpfStatusRequestOptions, cpfRequestOptions);
		baseOptions.set(CPFRequestKeys.CPF_STATUS, cpfStatusRequestOptions);

		this.setBaseOptions(baseOptions);
	}

	setBaseOptions(baseOptions) {
		this.baseOptions = baseOptions;
	}

	getBaseHttpRequest(key) {
		if (this.baseOptions === null) {
			this.setOptionsMaps();
		}
		const baseOptions = this.baseOptions.get(key);
		return new HttpRequest(_.cloneDeep(baseOptions), null, null, null);
	}
}

module.exports = CPFServiceRequestContext;
