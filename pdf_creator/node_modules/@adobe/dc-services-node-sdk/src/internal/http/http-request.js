/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const httpUtil = require('./http-client').http,
	httpHandler = require('./http-handler').handleJsonHttp,
	DCDefaultConfig = require('./../config/dc-services-default-config'),
	UrlTemplate = require('url-template'),
	logger = require('./../logger'),
	FormData = require('form-data');

/* eslint class-methods-use-this:0 */

/**
 * Utility method to convert the dc request options like headers, timeouts, etc. to a format understood by the
 * http client which is used.
 * @param dcRequestOptions
 */
const convertToHttpRequestOptions = dcRequestOptions => {
		const httpRequestOptions = Object.assign({}, dcRequestOptions, { requestConfig: undefined }),
			requestConfig = dcRequestOptions.requestConfig;
		// Uri template will be set by all the operation API calls
		if (requestConfig.uriTemplate) {
			const template = UrlTemplate.parse(requestConfig.uriTemplate);
			requestConfig.uri = template.expand(requestConfig.uriParams);
		}
		httpRequestOptions.uri = requestConfig.uri;
		httpRequestOptions.method = requestConfig.method;

		// timeout is considered as connect timeout
		httpRequestOptions.timeout = requestConfig.connectTimeout || DCDefaultConfig.http.connectTimeout;
		httpRequestOptions.readTimeout = requestConfig.readTimeout || DCDefaultConfig.http.readTimeout;
		logger.debug(`Resolved request uri : ${requestConfig.uri}`);
		return httpRequestOptions;
	};

class HttpRequest {
	constructor(options, identityAccess, content, fileDataList) {
		this.options = options;
		this.identityAccess = identityAccess;
		this.content = content;
		this.fileDataList = fileDataList;
	}

	withAuthenticator(identityAccess){
		this.identityAccess = identityAccess;
		return this;
	}

	set uriParams(uriParams) {
		this.options.requestConfig.uriParams = uriParams;
	}

	set bodyContent(content) {
		this.content = content;
	}

	set multipartContent(multipartContent) {
		this.fileDataList = multipartContent;
	}

	set stringBodyPart(contentAnalyzerRequest) {
		this.contentAnalyzerRequest = contentAnalyzerRequest;
	}

	get requestOptions() {
		return this.options;
	}

	call() {
		return this.execute()
			.then(result => {

				if ((result.status === 401 || result.statusCode === 401) && this.isAuthRequired()) {
					return this.execute(true)
						.then(res => Promise.resolve(res))
						.catch(err => Promise.reject(err));
				}
				return Promise.resolve(result);
			})
			.catch(err => Promise.reject(err));
	}

	execute(forced = false) {
		return this.authenticate(forced)
			.then(authContent => {

				if (authContent) {
					this.options.headers['Authorization'] = authContent.authToken;
					this.options.headers['x-api-key'] = authContent.x_api_key;
				}
				const ahttp = httpHandler(httpUtil),
					options = convertToHttpRequestOptions(this.options),
					content = this.content,
					fileDataList = this.fileDataList,
					contentAnalyzerRequest = this.contentAnalyzerRequest;

				if (fileDataList) {
					// Generate form data
					let formData = new FormData();
					formData.append('contentAnalyzerRequests', contentAnalyzerRequest);
					let index = 0;
					fileDataList.forEach(buffer =>
					{
						formData.append('file' + index, buffer.data);
						index++;
					});

					// Handle multipart content size limitation here
					let multipart_content_size_limit = 104857600; // 100 MBs in bytes
					const multipart_content_size = formData.getLengthSync();
					if(multipart_content_size > multipart_content_size_limit) {
						throw new Error('Total input file(s) size exceeds the acceptable limit');
					}

					// Set request headers for the multipart request
					options.headers['Content-Length'] = multipart_content_size;
					options.headers['Content-Type'] = `multipart/form-data;boundary=${formData.getBoundary()}`;
					options.headers['Transfer-Encoding'] = 'chunked';


					return ahttp.call(options, null, formData).then(res => Promise.resolve(res))
						.catch(err => Promise.reject(err));
				}

				return ahttp.call(options, content)
					.then(res => Promise.resolve(res))
					.catch(err => Promise.reject(err));
			})
			.catch(err => Promise.reject(err));
	}

	authenticate(forced) {
		if (this.isAuthRequired()) {

			return this.identityAccess.getSessionToken(forced)
				.then(res => Promise.resolve({
					authToken: `Bearer ${res.access_token}`,
					x_api_key: this.identityAccess.config.clientId
				}))
				.catch(err => Promise.reject(err));
		}
		return Promise.resolve(null);
	}

	isAuthRequired() {
		return this.options.authenticate === true;
	}
}

module.exports = HttpRequest;
