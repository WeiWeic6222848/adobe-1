/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const ServiceApiError = require('../../error/service-api-error'),
	ServiceUsageError = require('../../error/service-usage-error'),
	http = require('http'),
	https = require('https'),
	zlib = require('zlib'),
	_ = require('lodash/core'),
	Url = require('url'),
	DefaultHeaders = require('./default-dc-request-options'),
	logger = require('./../logger'),
	specialHttpErrorCodes = require('./../config/dc-services-default-config').specialHttpErrorCodes,
	apiGatewayErrorCodes = require('./../config/dc-services-default-config').apiGatewayErrorCodes,
	cpfErrorCodes = require('./../config/dc-services-default-config').cpfErrorCodes,
	imsErrorCodes = require('./../config/dc-services-default-config').imsErrorCodes;

// IMS error handling specific constants
const IMS_CERTIFICATE_EXPIRY_ERROR_DESCRIPTION_STRING = 'Could not match JWT signature to any of the bindings';

function rejectWithServiceApiError(requestOptions, promiseReject, httpResponse) {
	if (requestOptions.authenticate === true) {
		promiseReject(new ServiceApiError(
			specialHttpErrorCodes[httpResponse.status],
			requestOptions.headers[DefaultHeaders.DC_REQUEST_ID_HEADER_KEY], httpResponse.status
		));
	}
	promiseReject(new ServiceApiError(
		specialHttpErrorCodes[httpResponse.status],
		requestOptions.headers[DefaultHeaders.SESSION_TOKEN_REQUEST_ID_HEADER_KEY], httpResponse.status
	));
}
function handleJsonResponse(result, reject, options) {
	try {
		result.content = JSON.parse(result.content);
		// Merging different types of possible error message fields into a single one
		result.content.message = result.content.message || result.content.report || result.content.title;
	} catch (e) {
		rejectWithServiceApiError(options, reject, result);
	}
}

 /**
  * Returns custom error messages corresponding to specific error bound codes and conditions
  */
function getCustomErrorMessage(result) {
	 if(result.content.error_code) { // API gateway errors
		 let apiGatewaySubErrorCodesForStatus = apiGatewayErrorCodes[result.status];
		 if(apiGatewaySubErrorCodesForStatus && apiGatewaySubErrorCodesForStatus[result.content.error_code]) {
			 return apiGatewaySubErrorCodesForStatus[result.content.error_code].errorMessage;
		 }
	 } else if(result.content.type) { // CPF errors
		let cpfSubErrorCodesForStatus = cpfErrorCodes[result.status];
		if(cpfSubErrorCodesForStatus) {
			let errorBody = JSON.parse(result.content.type);
			if(cpfSubErrorCodesForStatus[errorBody.error_code]) {
				return cpfSubErrorCodesForStatus[errorBody.error_code].errorMessage;
			}
		}
	} else if(result.content.error) { // IMS errors
		let imsErrorCode = imsErrorCodes[result.status];
		if(imsErrorCode) {
			let errorSubCode = imsErrorCode[result.content.error];
			if(errorSubCode) {
				// Special handling for invalid token and certificate expiry cases from IMS (status code 400)
				if(result.status == 400) {
					if(result.content.error_description === IMS_CERTIFICATE_EXPIRY_ERROR_DESCRIPTION_STRING) {
						return errorSubCode.imsCertificateExpiredErrorMessage;
					} else {
						return errorSubCode.imsInvalidTokenGenericErrorMessage
					}
				}
			}
		}
	}
}

module.exports = {
	http: {
		isTextContentType(type) {
			return (/^text\/|json;|json$|xml;|xml$|svg;|svg$/).test(type);
		},
		getHeader(map, name) {
			if (!map || !name) {
				return null;
			}
			const result = map[name];
			return result !== undefined ? result : map[String(name)
				.toLowerCase()];
		},
		getRequestId(options) {
			return options[DefaultHeaders.DC_REQUEST_ID_HEADER_KEY] ||
				options[DefaultHeaders.SESSION_TOKEN_REQUEST_ID_HEADER_KEY];
		},
		call(requestParams, content, multiPartData) {
			const self = this,
				url = requestParams.uri,
				options = _.extend(requestParams || {}, Url.parse(url)),
				httpLib = options.protocol === 'http:' ? http : https;
			if (content) {
				if (_.isString(content)) {
					options.headers['Content-Length'] = content.length;
				}
				if (!self.getHeader(options.headers, 'Content-Type')) {
					options.headers['Content-Type'] =
						'application/x-www-form-urlencoded; charset=UTF-8';
				}
			}
			return new Promise(((fulfill, reject) => {
				let res;
				const ary = [];
				function onError(err) {
					logger.error(`Unexpected Error, request could not be completed ${err}`);
					reject(new Error(`Unexpected error encountered while executing request ${err}`));
				}
				function onData(chunk) {
					if (chunk) {
						ary.push(chunk);
					}
				}
				function onEnd(chunk) {
					if (chunk) {
						ary.push(chunk);
					}
					const resType = res.headers['content-type'],
						result = {
							status: res.statusCode,
							statusText: res.statusText || res.statusCode,
							headers: res.headers,
							content: self.isTextContentType(resType) ?
								ary.join('') :
								(ary.length === 1 ? ary[0] : Buffer.concat(ary))
						};

					if (specialHttpErrorCodes[result.status]) {
						rejectWithServiceApiError(options, reject, result);
					}

					// Allow 401 status response to resolve for request retry
					if (result.status >= 400 && result.status != 401) {
						handleJsonResponse(result, reject, options);
						let customErrorMessage = getCustomErrorMessage(result);
						// Reject with ServiceUsageError for Service Usage Errors with status code 429
						if(result.status == 429) {
							reject(new ServiceUsageError(
								customErrorMessage || result.content.message,
								result.headers[DefaultHeaders.DC_REQUEST_ID_HEADER_KEY], result.status
							));
						}
						reject(new ServiceApiError(
							customErrorMessage || result.content.error_description || result.content.message,
							result.headers[DefaultHeaders.SESSION_TOKEN_REQUEST_ID_HEADER_KEY]
								|| result.headers[DefaultHeaders.DC_REQUEST_ID_HEADER_KEY],
							result.status
						));
					} else {

						fulfill(result);
					}

					fulfill(result);
				}
				const req = httpLib.request(options, response => {
					res = response;
					// response_content_open is set to true for download file cases
					if (options.response_content_open) {

						if(res.statusCode >= 400) {
							res.on('data', onData);
							res.on('end', onEnd);
						} else {

							fulfill(response);
						}
					} else if (/gzip/.test(res.headers['content-encoding'])) {

						const gunzip = zlib.createGunzip();
						res.pipe(gunzip);
						gunzip.on('data', data => {
							ary.push(data.toString());
						})
							.on('end', onEnd);
					} else {

						res.on('data', onData);
						res.on('end', onEnd);
					}
				});
				req.setTimeout(options.readTimeout);
				req.on('error', onError);
				req.on('timeout', () => {
					req.destroy();
					reject(new ServiceApiError(
						`request timed out, ${options.timeout / 1000} seconds expired`,
						self.getRequestId(options), null
					));
				});
				if (options.request_content_open) {
					multiPartData.pipe(req);
					req.end();
				} else {
					if (content) {
						req.write(content);
					}
					req.end();
				}
			}));
		}
	}
};
