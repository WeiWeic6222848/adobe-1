/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const CPFRequestKeys = require('../cpf/cpf-service-request-key'),
	  logger = require('../logger'),
	  defer = require('../defer'),
	  { ensureDirectoryExistence } = require('../util/file-util'),
	  fs = require('fs'),
	  FileRef = require('../../io/file-ref'),
	  specialHttpErrorCodes = require('./../config/dc-services-default-config').specialHttpErrorCodes,
	  DefaultHeaders = require('../http/default-dc-request-options'),
      temp = require('temp-dir'),
	  path = require('path'),
	  ServiceApiError = require('../../error/service-api-error'),
	  formidable = require('formidable');

// private methods
const cpfPredictApiUtil = (context, bufferList, contentAnalyzerRequest) => context.getBaseRequestFromRequestContext(CPFRequestKeys.CPF_PREDICT)
	.then(httpRequest => {
		httpRequest.multipartContent = bufferList;
		httpRequest.stringBodyPart = contentAnalyzerRequest;
		logger.debug(`Uploading file with options ${JSON.stringify(httpRequest.requestOptions)}`);
		return httpRequest.call();
	}).catch(err => Promise.reject(err));

/**
 * This represents the onRejected method for a promise. Only supports a single parameter which is the error encountered
 * in the promise chain.  Adding more parameters will result in unexpected behaviour.
 *
 * @param err
 */
rejectPromiseWithError = err => Promise.reject(err);

const getFileData = (file) => {
	return new Promise((resolve, reject) => {
		let fileStream = file.input.asStream;
		let bufferChunks = [];

		fileStream.on('data', chunk => {
			bufferChunks.push(chunk);
		});

		fileStream.on('end', () => {
			const fileData = {
				data: Buffer.concat(bufferChunks)
			};
			resolve(fileData);
		});

		fileStream.on('error', error => reject(error));
	});
};

/**
 * This method parses the success result of cpfStatusApi and puts the content into specified file(fileName)
 * @param result
 * @param fileName
 * @returns {Promise<>}
 */
const parseSuccessResult = (result, fileName) => {
	const finished = defer(),
		tempDir = `${temp + path.sep}pdfServicesSdkResult${path.sep}`,
		filePath = tempDir + fileName;
	ensureDirectoryExistence(tempDir);

	// Parse multipart response data
	const form = formidable();
	form.onPart = (part) => {
		// For the file part, explicitly add the fileName to let the formidable lib treat it as file instead of field
		if (part.name == 'file') {
			part.filename = fileName;
		}
		form.handlePart(part);
	};
	form.on('fileBegin', (filename, file) => {
		// Override the file part's file path with filePath
		file.path = filePath;
	});
	form.parse(result, (err, fields, files) => {
		// Check for contentAnalyzerResponse errors
		if(fields.statuses) {
			let contentAnalyzerResponse = fields.statuses[0].invocations[0];
			if(contentAnalyzerResponse.status >= 400) {
				return finished.reject(new ServiceApiError(
					contentAnalyzerResponse.message,
					fields.request_id,
					parseInt(contentAnalyzerResponse.status)
				));
			}
		}

		// File has already been downloaded at filePath by formidable
		fs.chmodSync(filePath, '600');
		finished.resolve(FileRef.createFromLocalFile(filePath));
	});
	return finished.promise;
};

CPFApi = {

	cpfPredictApi(context, files, contentAnalyzerRequest) {
		return new Promise((resolve, reject) => {
			const promises = [];
			let fileDataList = [];

			// Generate individual file body parts
			let index = 0;
			files.forEach(file => {
				// To maintain the file ordering, assign unique index to every file input
				let localIndex = index;
				index++;
				promises.push(new Promise( (resolve, reject) => {
					getFileData(file)
						.then(fileData => {
							fileDataList[localIndex] = fileData;
							resolve();
						})
						.catch(error => reject(error))
				}));
			});

			// Resolve when all the file body parts are fully generated
			Promise.all(promises)
				.then( () => {
					cpfPredictApiUtil(context, fileDataList, contentAnalyzerRequest)
						.then(result => {
							if (result.status === 202) {
								resolve(result.headers.location);
							}
							reject(new ServiceApiError(
								result.content.message,
								result.headers[DefaultHeaders.DC_REQUEST_ID_HEADER_KEY],
								result.status
							));
						})
						.catch(err => reject(err))
				})
				.catch(err => reject(err));
		});
	},

	cpfStatusApi(context, location, fileName) {

		const startTime = new Date().getTime();
		const timeLimit = 1000 * 60 * 10; // 10 minutes in ms
		const pollingInterval = 1000; // 1 second in ms
		return context.getBaseRequestFromRequestContext(CPFRequestKeys.CPF_STATUS)
			.then(statusRequest => {
				statusRequest.options.requestConfig.uriTemplate = location;
				logger.debug(`Download file with options ${JSON.stringify(statusRequest.requestOptions)}`);
				return statusRequest.call();
			})
			.then(result => {
				if (result.statusCode === 200) {
					return parseSuccessResult(result, fileName);
				} else if(result.statusCode === 202) {
					logger.debug('poll');
					return new Promise((resolve, reject) => {
						if (new Date().getTime() - startTime > timeLimit) {
							logger.debug('Aborting conversion that is taking too long.');
							reject(new ServiceApiError(
								'Operation execution has timed out! Please find the last successful polling response',
								result.status, result.headers[DefaultHeaders.DC_REQUEST_ID_HEADER_KEY]
							));
						}
						setTimeout(() => {
							return this.cpfStatusApi(context, location, fileName)
								.then(targetFileRef => resolve(targetFileRef))
								.catch(err => reject(err));
						}, pollingInterval);
					});
				}
				if (specialHttpErrorCodes[result.statusCode]) {
					return Promise.reject(new ServiceApiError(
						specialHttpErrorCodes[result.statusCode],
						result.headers[DefaultHeaders.DC_REQUEST_ID_HEADER_KEY],
						result.statusCode
					));
				}
				return Promise.reject(new ServiceApiError(
					result.content.message,
					result.headers[DefaultHeaders.DC_REQUEST_ID_HEADER_KEY],
					result.statusCode
				));
			})
			.catch(rejectPromiseWithError);
	}
};

module.exports = CPFApi;
