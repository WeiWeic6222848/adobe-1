/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const CombinePDFApi = require('../internal/api/combine-pdf-api'),
	ExtensionMediaTypeMapping = require('../internal/extension-mediatype-mapping'),
	{ getRandomFileNameWithExtension } = require('../internal/util/path-util'),
	logger = require('./../internal/logger'),
	CombineOperationInput = require('./../internal/io/combine-operation-input'),
	PageRanges = require('./option/page-ranges'),
	{
		validateClientContext, validateFileWithPageOptions
	} = require('./../internal/util/validation-util');


const allowedConfiguration = {
	supportedMediaTypes: {
		PDF: ExtensionMediaTypeMapping.pdf.mediaType
	},

	getSupportedMediaTypes() {
		return Object.values(this.supportedMediaTypes);
	},

	supportedMediaTypesFromUrl: [],


	targetFileExtension: ExtensionMediaTypeMapping.pdf.extension

};

Object.freeze(allowedConfiguration);

/**
 * Combines multiple PDF files into a single PDF file. Allows specifying which pages of the source files to combine.
 *
 * Sample Usage:
 * <pre class="prettyprint">
 * <code>
 *
 *  const credentials = DCServicesSdk.Credentials.serviceAccountCredentialsBuilder()
 *            .fromFile("dc-services-sdk-credentials.json")
 *            .build(),
 *        executionContext = DCServicesSdk.ExecutionContext.create(credentials),
 *        combineFilesOperation = DCServicesSdk.CombineFiles.Operation.createNew(),
 *        input1 = DCServicesSdk.FileRef.createFromLocalFile('test/resources/combinePagesInput1.pdf'),
 *        input2 = DCServicesSdk.FileRef.createFromLocalFile('test/resources/combinePagesInput1.pdf'),
 *
 *  combineFilesOperation.addInput(input1);
 *  combineFilesOperation.addInput(input2);
 *
 *  combineFilesOperation.execute(executionContext)
 *      .then(result => result.saveAsFile('output/CombinedPDF.pdf'))
 *      .catch(err => console.log(err));
 * </code>
 * </pre>
 *
 */
class CombineFilesOperation {
	/**
     * @hideconstructor
     */
	constructor() {
		this.filesToCombine = [];
		Object.preventExtensions(this);
	}

	/**
     *
     * Constructs a {@link CombineFilesOperation} instance.
     * @returns {CombineFilesOperation} A new CombineFilesOperation instance.
     *
     */
	static createNew() {
		return new CombineFilesOperation();
	}

	/* eslint no-param-reassign:0 */
	/**
     * Specifies particular pages of a PDF file (media type "application/pdf") to be combined with other files. The pages
     * will be added after the pages of any previously specified files. If the <code>pageRanges</code> argument is not
     * provided, all pages of the PDF will be added in the combined PDF.
     * <p>
     *
     * @param {!FileRef} sourceFileRef - A PDF file to be combined.
     * @param {PageRanges=} pageRanges - Page ranges of the PDF file to be combined.
     */
	addInput(sourceFileRef, pageRanges) {
		if (!pageRanges) {
			pageRanges = new PageRanges();
			pageRanges.addAll();
		}
		this.filesToCombine.push(CombineOperationInput.createNew(sourceFileRef, pageRanges));
	}

	/**
     * Executes this operation using the supplied context and returns a Promise which resolves to the operation result.
     *
     * The resulting file may be stored in the system temporary directory (per the os.tempdir(), symlinks are resolved
     * to the actual path).
     * See {@link FileRef} for how temporary resources are cleaned up.
     *
     * @param {!ExecutionContext} context - The context in which the operation will be executed.
     * @returns {Promise<FileRef>} A promise which resolves to the operation result.
     * @throws {ServiceApiError} if an API call results in an error response.
	 * @throws {ServiceUsageError} if service usage limits have been reached or credentials quota has been exhausted.
     */
	execute(context){
		try {
			this.validate(context);
		} catch (err) {
			return Promise.reject(err);
		}
		const targetFileName = getRandomFileNameWithExtension(allowedConfiguration.targetFileExtension);
		logger.info('All validations successfully done. Beginning Combine Operation execution');
		return new Promise((resolve, reject) => {
			CombinePDFApi.combineFiles(
				context,this.getSourceFileRefs() ,this.getIncludeRanges() ,
				targetFileName
			)
				.then(res => resolve(res))
				.catch(err => reject(err));
		});
	}

	validate(context) {
		validateClientContext(context);
		if (this.filesToCombine.length === 0) {
			throw new Error('No input was provided for combining files');
		}
		this.filesToCombine.forEach(file => {
			validateFileWithPageOptions(file, allowedConfiguration.getSupportedMediaTypes());
		});
		if (this.filesToCombine.length > 12) {
			throw new Error('Only 12 input files can be combined in one combine operation instance');
		}
	}

	getIncludeRanges() {
		const includeRanges = [];
		this.filesToCombine.forEach(file => includeRanges.push(file.getPageRanges()
			.toString()));
		return includeRanges;
	}
	getSourceFileRefs(){
		var sourceFileRefs = [];
		this.filesToCombine.forEach(file => sourceFileRefs.push(file.getSourceFileRef()));
		return sourceFileRefs;
	}
}

Object.freeze(CombineFilesOperation);
module.exports = CombineFilesOperation;
